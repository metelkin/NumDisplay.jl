var documenterSearchIndex = {"docs":
[{"location":"api/#API-references","page":"API","title":"API references","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [NumDisplay]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#NumDisplay.DisplayBCD","page":"API","title":"NumDisplay.DisplayBCD","text":"struct DisplayBCD <: DisplayNoBuffer\n    digits_pins::AbstractVector{Int}      # pin numbers to control digits: [LSD ... MSD]\n    sectors_pins::Tuple{Int,Int,Int,Int,Int,Int,Int,Int}  # pin numbers for binary code: (d0,d1,d2,d3,-,-,-,DP)\n    buffer::AbstractVector{UInt8}         # internal storage of digits values\n    usDelay::Int                          # duration of period when digit is on\n    inverted_digits::Bool                 # if digit pins states must be inverted, i.e. 1 means LOW pin state\n    inverted_sectors::Bool                # if input pins and dp pin states must be inverted, i.e. 1 means LOW pin state\n    intensity::Int                        # 16 max\n    limit::Int\n    test_mode::Bool\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NumDisplay.DisplayBCD-2","page":"API","title":"NumDisplay.DisplayBCD","text":"function DisplayBCD(\n    digits_pins::AbstractVector{Int},\n    sectors_pins::Tuple{Int,Int,Int,Int,Int}, # A, B, C, D, DP\n    scan_rate::Real = 800,                    # Hz\n    inverted_digits::Bool = false\n    inverted_sectors::Bool = false\n)\n\nCreates device representing numerical display with several digits under control of the BCD chip. The number of display digits equal to digits_pins count.\n\nArguments\n\ndigits_pins : Vector of GPIO pin numbers connected to anode. The HIGH state means the digit is on. LOW means off.   The first pin in array should manage the less significant digit.\nsectors_pins : Tuple of length 5 consisting of GPIO numbers representing the 4-bit code of a digit.   The sequence of pins is the following: (d0, d1, d2, d3, DP).\nscan_rate : refresh rate of digits in Hz.    The digits in display are controlled by impulses of digits_pins.    This argument sets the time period for display of one digit.   If scan_rate=1000 the width will be recalculated as 1/1000 = 1e-3 second or 1e3 microsecond.   The default value is 800 Hz.\ninverted_digits : \ninverted_sectors :\n\n\n\n\n\n","category":"type"},{"location":"api/#NumDisplay.DisplayDirect","page":"API","title":"NumDisplay.DisplayDirect","text":"mutable struct DisplayDirect <: DisplayNoBuffer\n    digits_pins::AbstractVector{Int}             # pins' numbers to control digit: [LSD ... MSD]\n    sectors_pins::Tuple{Int,Int,Int,Int,Int,Int,Int,Int} # pins' number to control sectors: (g,f,e,d,c,b,a,DP) | (d0,d1,d2,d3,-,-,-,DP)\n    buffer::AbstractVector{UInt8}                # storage for current digit values\n    usDelay::Real                                # duration of one active digit\n    inverted_digits::Bool                        # if digit pins states must be inverted, i.e. 1 means LOW pin state\n    inverted_sectors::Bool                       # if sectors pins' states must be inverted, i.e. 1 means LOW pin state\n    decode_mode::UInt8                           # current decode mode for digits, 0b00000001 - only first digit is in decode mode\n    intensity::Int                               # value from 1 to 16, brightness controlled by pulse-width\n    limit::Int                                   # current number of digits to show\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NumDisplay.DisplayDirect-Tuple{AbstractVector{Int64}, NTuple{8, Int64}}","page":"API","title":"NumDisplay.DisplayDirect","text":"function DisplayDirect(\n    digits_pins::AbstractVector{Int},\n    sectors_pins::Tuple{Int,Int,Int,Int,Int,Int,Int,Int};\n    scan_rate::Real = 800, # Hz\n    inverted_digits::Bool = false,\n    inverted_sectors::Bool = false\n)\n\nCreates numerical display device controlled directly with the RaspberryPi pins. The number of display digits equal to digits_pins count. DisplayDirect stores its states in internal buffer and creates the pulse-width wave  to show digits on a physical device.\n\nInitial state of display:\n\nshutdown mode on. Use method shutdown_mode_off() to activate the display before the first use.\ntest mode off.\ndecode mode is on for all digits.\nlimit value is equal to all available digits, see size()\nintensity = 5\nbuffer is zero for all digits. \n\nArguments\n\ndigits_pins : Vector of GPIO pin numbers connected to common anode or cathode.   The first pin in array manages the less significant digit (LSD) of display.   The value -1 is also possible here which means that the digit will not be used.\nsectors_pins : Tuple of length 8 consisting of GPIO numbers controlling   the states of 8 sectors.   The sequence of pins is the following: (g, f, e, d, c, b, a, DP).   This corresponds to the sequence of bits (starting from most significant) in buffer.   The value -1 is also possible here which means that the pin will not be used.\nscan_rate : refresh rate of digits in Hz.    The digits in display are controlled by impulses of digits_pins.    This argument sets the time period for display of one digit.   If scan_rate=1000 the width will be recalculated as 1/1000 = 1e-3 second or 1e3 microsecond.   The default value is 800 Hz.\ninverted_digits : This option inverts digit_pins active states.\ninverted_sectors : This option inverts sectors_pins active states.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.decode_mode","page":"API","title":"NumDisplay.decode_mode","text":"function decode_mode(d::AbstractNumDisplay, decode::UInt8 = 0b1111_1111)\n\nThe decode-mode register sets BCD code (0-9, E, H, L, P, and -) or no-decode operation for each digit. \n\nWhen the code B decode mode is used, the decoder looks only at the lower nibble of the data in the digit registers (D4–D1), disregarding bits D5–D7. D8 sets the decimal point (DP).\n\nWhen no-decode is selected, data bits D8–D1 correspond to the segment lines\n\nall digits in decode mode => 0xff = 0b11111111 all digits in none-decode mode => 0x00 = 0b00000000 first decode other none mode => 0x01 = 0b0000_0001\n\nArguments\n\nd : device instance\ndecode : Each bit in the register corresponds to one digit. A logic high   selects code decoding while logic low bypasses the decoder.\n\n\n\n\n\n","category":"function"},{"location":"api/#NumDisplay.scan_rate-Tuple{DisplaySPI}","page":"API","title":"NumDisplay.scan_rate","text":"scan rate = 800 Hz (500-1300) from chip docs\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.scan_rate-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.scan_rate","text":"scan_rate(d::AbstractNumDisplay)\n\nGetter to display actual refresh rate.\n\nReturn\n\nInt value in Hz \n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.set_intensity","page":"API","title":"NumDisplay.set_intensity","text":"function set_intensity(d::AbstractNumDisplay, intensity::Int = 16)\n\nDigital control of display brightness is provided by an internal pulse-width modulator.\n\nArguments\n\nd : device instance\nintensity : the value from 1 to 16 controlling the brighness.    The modulator scales the average segment current in 16 steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#NumDisplay.set_limit","page":"API","title":"NumDisplay.set_limit","text":"function set_limit(d::AbstractNumDisplay, limit::Int = size(d))\n\nThe function sets how many digits are displayed. Since the number of scanned digits affects the display brightness, the scan-limit register should not be used to blank portions of the display.\n\nThe default value equal to the maximal value.\n\nArguments\n\nd : device instance\nlimit : number of active digits, from 1 to size(d)   1 means only digit 1 is shown. 4 meand 8 digits will be shown.\n\n\n\n\n\n","category":"function"},{"location":"api/#NumDisplay.shutdown_mode_off-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.shutdown_mode_off","text":"shutdown_mode_off(d::AbstractNumDisplay)\n\nSets the normal mode, i.e. display digits. It should be run after initialization of device.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.shutdown_mode_on-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.shutdown_mode_on","text":"shutdown_mode_on(d::AbstractNumDisplay)\n\nIn shutdown mode you can update digits values and set different settings but nothing will be shown. Shutdown can be used to save power or as an alarm to flash the display by successively entering and leaving shutdown mode.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.size-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.size","text":"size(d::AbstractNumDisplay)\n\nGetter to show the maximal number of digits available for the display. This is equal to the number of digits_pins.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.test_mode_off-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.test_mode_off","text":"function test_mode_off(d::AbstractNumDisplay)\n\nSets the normal mode, i.e. display digits.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.test_mode_on-Tuple{NumDisplay.AbstractNumDisplay}","page":"API","title":"NumDisplay.test_mode_on","text":"function test_mode_on(d::AbstractNumDisplay)\n\nDisplay-test mode turns all LEDs on. Test mode overrides shutdown mode. Display remain in display-test mode until the display is reconfigured for normal operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.update-Tuple{NumDisplay.DisplayNoBuffer}","page":"API","title":"NumDisplay.update","text":"function update(d::DisplayNoBuffer)\n\nGenerates a sequence of pulses based on buffer, decode_mode, intensity, limit, and runs pulses repeatedly. The function is used internally after buffer and modes changes. If a display is in shutdown mode, the function does nothing. \n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.write_digit-Tuple{NumDisplay.AbstractNumDisplay, UInt8, Int64}","page":"API","title":"NumDisplay.write_digit","text":"write_digit(\n    d::AbstractNumDisplay,\n    value::UInt8,\n    position::Int\n)\n\nWrites a digit to the position. The result of the execution is changing one digit.\n\nThe result will depend on decode mode, see decode_mode() function. The most significant bit sets the DP (dot) state.\n\nIn non-decode mode the bits 7-0 manage the sectors a, b, c, d, e, f, g.\n\nIn decode mode only bits 3-0 play a role. The sequence of numbers is the following: 0,1,2,3,4,5,6,7,8,9,-,E,H,L,P,blank\n\nArguments\n\nd : object representing display device\nvalue : UInt8 value updating the buffer value.\nposition : number of digit to write starting from 1 which mean least significant digit.   The maximal value depends on available digits, so it should be <= length(indicator.digit_pins)\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.write_digit-Tuple{NumDisplay.DisplayNoBuffer, UInt8, Int64}","page":"API","title":"NumDisplay.write_digit","text":"function write_digit(\n    indicator::DisplayBCD,\n    digit::Union{UInt8, Nothing},\n    position::Int\n)\n\nWrites a digit to the position. The result of the execution is changing one digit in a particular digit. \n\nArguments\n\nindicator : object representing display device\ndigit : decimal value from 0 to 9 or nothing. The last means an empty digit.       Values from 10 to 14 are also possible here but results to miningless symbols.       Value 15 means an empty digit and it is the same as nothing.\nposition : number of digit to write starting from 1 which mean less significant digit.       The maximal value depends on available digits, so it should be <= length(indicator.digit_pins)\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.write_number","page":"API","title":"NumDisplay.write_number","text":"write_number(\n    indicator::AbstractNumDisplay,\n    number::Int,\n    dp_position::Union{Int, Nothing} = nothing\n)\n\nWrites the decimal value to the display.\n\nArguments\n\nindicator : object representing display device\nnumber : decimal number. The maximal possible value depends on number of digits and will be checked.\ndp_position : position of digit starting from less significant digit or nothing.\n\nExample\n\n# d is 4-digit display\nwrite_number(d, 123)\n# the result is _123\n\nwrite_number(d, 1234)\n# the result is 1234\n\nwrite_number(d, 12345)\n# throws an error\n\n\n\n\n\n","category":"function"},{"location":"api/#NumDisplay.write_number-Union{Tuple{D}, Tuple{NumDisplay.AbstractNumDisplay, AbstractArray{D, N} where N}, Tuple{NumDisplay.AbstractNumDisplay, AbstractArray{D, N} where N, Union{Nothing, Int64}}} where D<:Union{Nothing, Int64}","page":"API","title":"NumDisplay.write_number","text":"Writes several digits Runs display in decode mode and display several digits element in numer_vector must be Integers\n\n\n\n\n\n","category":"method"},{"location":"api/#NumDisplay.write_symbols-Tuple{NumDisplay.AbstractNumDisplay, AbstractArray{UInt8, N} where N}","page":"API","title":"NumDisplay.write_symbols","text":"works in segment-wise mode set active segments DP A B C D E F G\n\n\n\n\n\n","category":"method"},{"location":"bcd/#BCD-approach","page":"BCD","title":"BCD approach","text":"","category":"section"},{"location":"bcd/","page":"BCD","title":"BCD","text":"BCD is a Binary-Coded Decimal chip which can be used to manage display with several digits.","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"The chip transforms the binary code (4 bits: A, B, C, D) to the 7-segment (a,b,c,d,e,f,g) LED states representing decimal number. If you use the indicator with common anode you need to switch the digits by additional signal: one pin for one digit. ","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"The method requires 4 pins to display decimal and additionally one pin per digit. If you use dot on display you need the additional pin. For example 4-digits-display requires 4 + 1 + 4 = 9 GPIO pins.  8-digits-display requires 4 + 1 + 8 = 13 GPIO pins.","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"Common anode chips examples","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"246 : SN54246, SN74246\n247 : SN54247, SN74247\nLS247 : SN54LS247, SN74LS247(*)\nLS248 : SN54LS248, SN74LS248","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"(*) was tested","category":"page"},{"location":"bcd/#Usage","page":"BCD","title":"Usage","text":"","category":"section"},{"location":"bcd/","page":"BCD","title":"BCD","text":"Without dot","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"using NumericDisplay\nd = DisplayBCD(\n    [       # pins to on/off digits\n        5,  # less significant decimal digit\n        6,\n        13,\n        19   # most significant decimal digit\n    ],\n    (      # pins connected to chip to transform bits to decimal number\n        2, # A (less significant bit)\n        3, # B\n        4, # C\n        17 # D (most significant bit)\n        -1 # no pin for dot\n    )\n)\n\nwrite_number(d, 666) # write _666\nshutdown_mode_off(d) # display _666\n\nsleep(1)\nshutdown_mode_on(d)              # display nothing","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"With dot","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"using NumericDisplay\nd = DisplayBCD(\n    [       # pins to on/off digits\n        5, # less significant decimal digit\n        6,\n        13,\n        19   # most significant decimal digit\n    ],\n    (      # pins connected to chip to transform bits to decimal number\n        2, # A (less significant bit)\n        3, # B\n        4, # C\n        17, # D (most significant bit)\n        27 # pin to control dot\n    )    \n)\n\nshutdown_mode_off(d)\nwrite_number(d, 666) # display _666\nsleep(1)\nwrite_number(d, 666, 2) # display _66.6\nsleep(1)\nshutdown_mode_on(d)     # display nothing","category":"page"},{"location":"bcd/#Circuit","page":"BCD","title":"Circuit","text":"","category":"section"},{"location":"bcd/","page":"BCD","title":"BCD","text":"Without dot","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"(Image: bcd-scheme)","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"(Image: Watch the video)","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"Notes","category":"page"},{"location":"bcd/","page":"BCD","title":"BCD","text":"Here I was using the NPN transistors to switch digits because I had them but MOSFETs was also possible there.\nTo use the dot symbol (which is also available on the indicator) it is required to add one additional pin.","category":"page"},{"location":"direct/#Direct-approach","page":"Direct","title":"Direct approach","text":"","category":"section"},{"location":"direct/","page":"Direct","title":"Direct","text":"This method does not require any chip. Each segment in digit is managed by its own GPIO pin. It can serve the common-anode and common-cathod display.","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"The method requires 7 pins to display decimal and additionally one pin per digit. For example 4-digit-display requires 8 + 4 = 12 GPIO pins.  8-digit-display requires 8 + 8 = 15 GPIO pins.","category":"page"},{"location":"direct/#Usage","page":"Direct","title":"Usage","text":"","category":"section"},{"location":"direct/","page":"Direct","title":"Direct","text":"Without dot","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"using NumericDisplay\nd = DisplayDirect(\n    [       # pins to on/off digits\n        27, # less significant decimal digit\n        22,\n        10,\n        9   # most significant decimal digit\n    ],\n    (      # pins connected to segments\n        7, # g segment\n        8, # f\n        25, # e\n        24, # d\n        23, # c\n        18, # b\n        15, # a\n        -1  # DP not used\n    );\n    inverted_sectors = true\n)\nshutdown_mode_off(d)\nwrite_number(d, 666) # display _666\n\nsleep(1)\nshutdown_mode_on(d)              # display nothing","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"With dot","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"using NumericDisplay\nd = DisplayDirect # pins to on/off digits\n        27, # less significant decimal digit\n        22,\n        10,\n        9   # most significant decimal digit\n    ],\n    (       # pins connected to segments\n        7,  # g segment\n        8,  # f\n        25, # e\n        24, # d\n        23, # c\n        18, # b\n        15, # a\n        14  # DP pin\n    );   \n    inverted_sectors = true\n)\n\nshutdown_mode_off(d)\n\nwrite_number(d, 666) # display _666\nsleep(1)\nwrite_number(d, 666, 2) # display _66.6\nsleep(1)\nshutdown_mode_on(d)              # display nothing","category":"page"},{"location":"direct/#Circuit","page":"Direct","title":"Circuit","text":"","category":"section"},{"location":"direct/","page":"Direct","title":"Direct","text":"Common anode and cathode scheme","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"(Image: direct-scheme-anode)","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"Notes","category":"page"},{"location":"direct/","page":"Direct","title":"Direct","text":"The scheme uses power from 3.3V signal pins. To use the external power you need to use NPN or MOSFET transistors.\nIf you use common anode, use DisplayDirect(...; inverted_sectors=true, inverted_sectors=false) in constructor.\nIf you use common cathode, use DisplayDirect(...; inverted_sectors=false, inverted_sectors=true) in constructor.","category":"page"},{"location":"#NumericDisplay","page":"Home","title":"NumericDisplay","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Raspberry Pi package for controlling the 7-segment numeric displays written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package supports several approaches:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Direct method does not use any chips transforming input but it requires more GPIO pins. See DisplayDirect.\nBCD is a Binary-Coded Decimal chip which can be used to manage display with several digits. See DisplayBCD.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia must be installed on Raspberry Pi.  I have tested on v1.1.0 which can be installed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo apt update\nsudo apt install julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can be installed from Julia environment with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/metelkin/NumDisplay.jl.git","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run the code you need the full access to GPIO. Run it under sudo privileges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example running the code from \"test/run.jl\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo julia --project=. test/run.jl","category":"page"}]
}
